'''
INPUT:
    Required:
        IAP Ozondesonde observation csv data edited by XZ
    Optional:
        Ground txt data

OUTPUT:
    Figures of profile: Tropopause, O3 (ppbv) and Qv (ppmv)

UPDATE:
    Xin Zhang:
        02/17/2020: basic
        04/24/2020: add tropopause hline
'''

import sys
import numpy as np
import pandas as pd
import metpy.calc as mpcalc
from metpy.units import units
import matplotlib.pyplot as plt
from scipy.signal import savgol_filter
from IAP_ozonesonde import read_profile, plot_profiles, comp_sondes

sys.path.append('../XZ_calcs')
sys.path.append('../XZ_model')
from pressure import correct_p

# --- input ---
sonde_1 = './data/ozonesonde/2_201907231329.txt'
sonde_2 = './data/ozonesonde/9_201907251434.txt'
# sonde_2 = './data/ozonesonde/5_201908041421.txt'

smooth = True
tslist_match = './data/ozonesonde/sonde_tslist.txt'
savedir = './figures/'
savename = 'sonde_profile.pdf'

def get_sonde_profile(sonde_1, sonde_2, smooth):
    '''
    Read ozonesonde profiles

    Return: two profile dicts
    '''

    # --------------- read data --------------- #
    profile_1, _ = read_profile(sonde_1, smooth=smooth)
    profile_2, _ = read_profile(sonde_2, smooth=smooth)
    profile_1 = profile_1.reset_index(drop=True)
    profile_2 = profile_2.reset_index(drop=True)
    # --------------- correct data --------------- #
    # Because there's something wrong with ozonesonde,
    # we need to correct by ourself.
    profile_1['T'] -= 9

    # set surface pressure (hPa)
    profile_1['PR'][0] = 1001.60
    profile_2['PR'][0] = 998.4

    # correct pressures based on GPS and radiosonde
    corrected_profile_1 = correct_p(profile_1.copy())
    corrected_profile_2 = correct_p(profile_2.copy())

    # reassign and calculate water mixing ratio again ...
    profile_1 = corrected_profile_1
    profile_2 = corrected_profile_2

    profile_1['QV'] = mpcalc.mixing_ratio_from_relative_humidity(
                            pressure=profile_1['PR'].values * units.hPa,
                            temperature=profile_1['T'].values * units.degC,
                            relative_humidity=profile_1['rh'].values * units.percent)
    profile_2['QV'] = mpcalc.mixing_ratio_from_relative_humidity(
                            pressure=profile_2['PR'].values * units.hPa,
                            temperature=profile_2['T'].values * units.degC,
                            relative_humidity=profile_2['rh'].values * units.percent)

    # ---------  convert units ---------- #
    profile_1['QV'] *= 1e6  # ppm
    profile_2['QV'] *= 1e6  # ppm
    profile_1['h'] /= 1e3  # km
    profile_2['h'] /= 1e3  # km

    # ---------  calculate tropopause ---------- #
    # itrop_1, trop_1 = trop_wmo(np.flipud(profile_1['PR']), np.flipud(profile_1['T'] + 273.15))
    # itrop_2, trop_2 = trop_wmo(np.flipud(profile_2['PR']), np.flipud(profile_2['T'] + 273.15))
    # trop = [itrop_1, itrop_2]
    # print (trop_1, trop_2)

    return profile_1, profile_2

def get_match_data(tslist_match):
    '''
    Get the matched tslist data generated by `match_sonde_tslist.py`

    Return: the vertical profile DateFrame at each matched level (from bottom to up).

    '''
    df = pd.read_csv(tslist_match, header=0)
    df = df.iloc[1:].reset_index()
    df = df.apply(pd.to_numeric, errors='coerce')

    return df

def t_resolution(profile):
    '''Check the time resolution of sonde'''
    delta = profile['t'].diff().dt.total_seconds()
    plt.plot(delta, profile['h'])
    plt.xlabel('Time delta per signal (s)')
    plt.ylabel('Altitude (km)')
    plt.savefig('Time_delta.png')

def calc_tropo(profile, unit='hPa'):
    '''Finding the tropopause level using the WMO definition of a
       tropopause as being the lowest level where the 2 km layer
       aloft has a lapse rate greater than 2 C/km.

    Args: profile dict [PR (hPa), T (degree) and h (km)]
          unit: hPa or km

    Return: tropopause (km)

    Reference: https://github.com/tsupinie/SoundingFilter/blob/master/sndfilter.py
    '''

    p = profile['PR'].reset_index(drop=True)
    # crop data to smaller region
    above_500 = np.where((p > 75) & (p < 550))[0]
    t = profile['T'][above_500].reset_index(drop=True)
    h = profile['h'][above_500].reset_index(drop=True)

    # calculate difference and gamma
    dT = np.diff(t)
    dz = np.diff(h)
    mean_z = ((h[1:] + h[:-1]) * 0.5).reset_index(drop=True)
    gamma = dT / dz

    # check condition
    keep_gamma = np.isfinite(gamma) & (gamma > 2)

    if type(gamma) == np.ma.core.MaskedArray:
        keep_gamma &= (~gamma.mask)
    idx = np.where(keep_gamma)[0]

    for i in idx:
        hbot = mean_z[i]
        htop = hbot + 2.
        htop_idx = np.argmin(np.abs(mean_z - htop))
        mean_lapse = (t[htop_idx] - t[i]) / (h[htop_idx] - h[i])
        if mean_lapse > 2:
            if unit == 'hPa':
                return p[above_500[i]]
            elif unit == 'km':
                return h[above_500[i]]
    return np.nan

def plot_vars(profile_1, profile_2):
    '''Check all variables detected by ozonesonde'''

    fig, axes = plt.subplots(nrows=2, ncols=2, figsize=(10, 10))
    plot_profiles(profile_1, profile_2, 'T',  'h', '$^\circ$C', axes[0, 0])
    plot_profiles(profile_1, profile_2, 'PR',  'h', 'hPa',       axes[0, 1])
    plot_profiles(profile_1, profile_2, 'O3', 'h', 'ppb',       axes[1, 0])
    plot_profiles(profile_1, profile_2, 'QV',  'h', 'ppm',       axes[1, 1])
    plt.show()

def o3_qv(profile_1, profile_2, tropo_1, tropo_2, savefile, model_profile=None):
    '''
    Compare variables before convection and after convection

    Currently support:
      O3: detected by two sondes and simulated by model
      QV: detected by two sondes

    '''

    plt.rcParams.update({'axes.titlesize': 'xx-large',
                         'axes.labelsize': 'xx-large',
                         'ytick.labelsize': 'x-large',
                         'xtick.labelsize': 'x-large',
                         'legend.fontsize': 'x-large'})

    fig, ax = plt.subplots(figsize=(10, 10))

    # proplot has a bug of twinx:
    #   https://github.com/lukelbd/proplot/issues/127
    # import proplot as plot
    # plot.rc.update({'tick.labelsize': 6,
    #                 'toplabel.size': 8})
    # f, ax = plot.subplots(aspect=(2,3))
    # comp_sondes_proplot(profile_1, profile_2, ax, model_profile=model_profile)
    # f.savefig('sonde_proplot.png')

    # plot the tropopause line
    plt.axhline(y=tropo_1,
                color='grey',
                linestyle='--',
                label='Pre conv. Tropo',
                lw=2)
    plt.axhline(y=tropo_2,
                color='grey',
                linestyle='-',
                label='Post conv. Tropo',
                lw=2)

    comp_sondes(profile_1, profile_2, ax, 'QV')
    comp_sondes(profile_1, profile_2, ax, 'O3', model_profile=model_profile)

    handles, labels = [], []
    for ax in fig.axes:
        for h, l in zip(*ax.get_legend_handles_labels()):
            handles.append(h)
            labels.append(l)

    plt.legend(handles, labels, bbox_to_anchor=(1.15, 1), loc="upper left")
    plt.savefig(savefile, bbox_inches="tight")


def main():
    # read sonde data
    profile_1, profile_2 = get_sonde_profile(sonde_1, sonde_2, smooth)
    match_profile = get_match_data(tslist_match)
    match_profile['O3'] = savgol_filter(match_profile['O3'], 51, 3) # window size 51, polynomial order 3

    # check the data
    # plot_vars(profile_1, profile_2)

    # calculate tropopause
    tropo_1 = calc_tropo(profile_1)
    tropo_2 = calc_tropo(profile_2)

    # plot
    o3_qv(profile_1, profile_2, tropo_1, tropo_2, savedir+savename, match_profile)

if __name__ == '__main__':
    main()
